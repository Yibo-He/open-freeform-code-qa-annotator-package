
# Post \#73318552 [Link](https://stackoverflow.com/questions/73318552/)

## Django ORM query optimisation with multiple joins

**Vote**: 4 (532/702) **Views**: 449 (698/702) 

**Internal ID** \#1-3-227

Created at 2022-08-11 09:41:04

Tags: `python` `django` `django-models` `django-orm`

----------

#### Metadata:

Area: `Data Science & Machine Learning`

Language: `python` (full parsed tag list: `python`)

----------

**Notepad**


----------

In my app, I can describe an Entity using different Protocols, with each
Protocol being a collection of various Traits, and each Trait allows two or
more Classes. So, a Description is a collection of Expressions. E.g., I want to
describe an entity "John" with the Protocol "X" that comprises the following
two Traits and Classes:
 ABC
 1: Height
Available :
a. Short
b. Medium
c. Tall
 2: Weight
Available :
a. Light
b. Medium
c. Heavy
John's :  1: c. Tall,  2: b. Medium
My model specification (barebone essentials for simplicity):
```
class Protocol(models.Model):
    """
    A Protocol is a collection of Traits
    """
    name = models.CharField()

class Trait(models.Model):
    """
    Stores the Traits. Each Trait can have multiple Classes
    """

    name = models.CharField()
    protocol = models.ForeignKey(
        Protocol,
        help_text="The reference protocol of the trait",
    )

class Class(models.Model):
    """
    Stores the different Classes related to a Trait.
    """

    name = models.CharField()
    trait = models.ForeignKey(Trait)

class Description(models.Model):
    """
    Stores the Descriptions. A description is a collection of Expressions.
    """

    name = models.CharField()
    protocol = models.ForeignKey(
        Protocol,
        help_text="reference to the protocol used to make the description;\
            this will define which Traits will be available",
    )
    entity = models.ForeignKey(
        Entity,
        help_text="the Entity to which the description refers to",
    )

class Expression(models.Model):
    """
    Stores the expressions of entities related to a specific
    Description. It refers to one particular Class (which is
    then associated with a specific Trait)
    """

    class = models.ForeignKey(Class)
    description = models.ForeignKey(Description)
```

Following the previous example, let's say I want to find all the Entities that
are  or  (Trait 1) and  (Trait 2).
The query I'm now using is the following:
```
# This is the filter returned by the HTML form, which list
# all the available Classes for each Trait of the selected Protocol
filters = [
  {'trait': 1, 'class': [2, 3]},
  {'trait': 2, 'class': [6,]},
]

queryset = Description.objects.all()

for filter in filters:
  queryset = queryset.filter(expression_set__class__in=filter["class"])
```

The problem is that the query is slow (I have ATM ~1000 Descriptions, described with
a Protocol of 40 Traits, each Trait having 2 to 5 Classes). It takes about two
seconds to return the results even when filtering by only 5-6 Expressions.
I tried using `prefetch_related("expression_set")` or
`prefetch_related("expression_set__class")` but with no significant improvement.
The question is: can you suggest a way to improve the performance, or this is
simply the reality of searching through so many tables?
Thank you very much for your time.

---


EDIT:
The following is the query generated by the Manager when, e.g., eight filters (see previous code snippet) are applied.
```
SELECT "describe_description"."id",
       "describe_description"."name",
       "describe_description"."protocol_id",
  FROM "describe_description"
 INNER JOIN "describe_expression"
    ON ("describe_description"."id" = "describe_expression"."description_id")
 INNER JOIN "describe_expression" T4
    ON ("describe_description"."id" = T4."description_id")
 INNER JOIN "describe_expression" T6
    ON ("describe_description"."id" = T6."description_id")
 INNER JOIN "describe_expression" T8
    ON ("describe_description"."id" = T8."description_id")
 INNER JOIN "describe_expression" T10
    ON ("describe_description"."id" = T10."description_id")
 INNER JOIN "describe_expression" T12
    ON ("describe_description"."id" = T12."description_id")
 INNER JOIN "describe_expression" T14
    ON ("describe_description"."id" = T14."description_id")
 INNER JOIN "describe_expression" T16
    ON ("describe_description"."id" = T16."description_id")
 INNER JOIN "describe_expression" T18
    ON ("describe_description"."id" = T18."description_id")
 WHERE ("describe_expression"."class_id" IN (732) AND T4."class_id" IN (740) AND T6."class_id" IN (760) AND T8."class_id" IN (783) AND T10."class_id" IN (794) AND T12."class_id" IN (851) AND T14."class_id" IN (857) AND T16."class_id" IN (860) AND T18."class_id" IN (874))
```



----------
        
## GPT3.5 Attempt \#0

One possible solution to improve the performance of your query is to use subqueries instead of multiple joins. You can try using Django's `Subquery` expression to generate subqueries for each filter and then combine them using the `Q` object. Here's an example:

```
from django.db.models import Subquery, OuterRef, Q

filters = [
  {'trait': 1, 'class': [2, 3]},
  {'trait': 2, 'class': [6,]},
]

queryset = Description.objects.all()

for filter in filters:
  subquery = Expression.objects.filter(
    trait_id=filter['trait'],
    class_id__in=filter['class']
  ).values('description_id')
  queryset = queryset.filter(
    Q(id__in=Subquery(subquery))
  )
```

This code generates a subquery for each filter that selects the `description_id` of all expressions that match the filter. Then, it combines all subqueries using the `Q` object and applies the resulting filter to the `Description` queryset.

Another possible solution is to denormalize your data by adding a `TraitClass` model that stores the relationship between a `Trait` and a `Class`. This way, you can avoid the multiple joins and simplify your queries. Here's an example:

```
class TraitClass(models.Model):
    """
    Stores the relationship between a Trait and a Class.
    """

    trait = models.ForeignKey(Trait)
    class = models.ForeignKey(Class)

class Description(models.Model):
    """
    Stores the Descriptions. A description is a collection of Expressions.
    """

    name = models.CharField()
    protocol = models.ForeignKey(
        Protocol,
        help_text="reference to the protocol used to make the description;\
            this will define which Traits will be available",
    )
    entity = models.ForeignKey(
        Entity,
        help_text="the Entity to which the description refers to",
    )
    trait_classes = models.ManyToManyField(TraitClass)

filters = [
  {'trait': 1, 'class': [2, 3]},
  {'trait': 2, 'class': [6,]},
]

queryset = Description.objects.all()

for filter in filters:
  queryset = queryset.filter(
    trait_classes__trait_id=filter['trait'],
    trait_classes__class_id__in=filter['class']
  )
```

This code adds a `ManyToManyField` to the `Description` model that stores the relationship between a `Trait` and a `Class`. Then, it uses the `trait_classes` field to filter the `Description` queryset directly, without the need for multiple joins.

Note that denormalizing your data can have some drawbacks, such as increased storage requirements and complexity of updates. You should carefully consider the trade-offs before adopting this approach.

--------

## GPT3.5 Attempt \#1

One way to improve the performance of your query is to use subqueries instead of joining the same table multiple times. You can use Django's `Subquery` expression to create subqueries that filter the `Expression` table for each filter in your list. Then, you can combine these subqueries using the `Q` object to create a single query that filters the `Description` table.

Here's an example of how you can modify your code to use subqueries:

```
from django.db.models import Subquery, OuterRef, Q

# This is the filter returned by the HTML form, which list
# all the available Classes for each Trait of the selected Protocol
filters = [
  {'trait': 1, 'class': [2, 3]},
  {'trait': 2, 'class': [6,]},
]

# Create a list of subqueries that filter the Expression table for each filter
subqueries = []
for filter in filters:
  subquery = Subquery(
    Expression.objects.filter(
      description_id=OuterRef('id'),
      class_id__in=filter['class'],
      trait_id=filter['trait']
    ).values('id')
  )
  subqueries.append(subquery)

# Combine the subqueries using the Q object to create a single query
queryset = Description.objects.filter(
  Q(*[Q(expression_set__in=subquery) for subquery in subqueries])
)
```

This code creates a list of subqueries that filter the `Expression` table for each filter in your list. Each subquery uses the `Subquery` expression to filter the `Expression` table for the `Description` with the same `id` as the outer query, and for the `Class` and `Trait` specified in the filter. The `values` method is used to select only the `id` field of the `Expression` table, which is needed to create the subquery.

Then, the code combines the subqueries using the `Q` object to create a single query that filters the `Description` table. The `Q` object is used to create a list of queries that filter the `Expression` table using the subqueries created earlier. The `*` operator is used to unpack the list of queries into separate arguments for the `Q` object.

This approach should be more efficient than joining the same table multiple times, as it avoids creating redundant rows in the result set. It also allows the database to use indexes more efficiently, as each subquery only filters a small subset of the `Expression` table.

--------

## GPT3.5 Attempt \#2

One way to improve the performance of your query is to use subqueries instead of joining the same table multiple times. You can try using the `Subquery` expression in Django to achieve this.

Here's an example of how you can modify your query using subqueries:

```
from django.db.models import Subquery, OuterRef

filters = [
  {'trait': 1, 'class': [2, 3]},
  {'trait': 2, 'class': [6,]},
]

queryset = Description.objects.all()

for filter in filters:
  queryset = queryset.filter(
    expression_set__class__in=Subquery(
      Class.objects.filter(
        trait_id=filter['trait'],
        id__in=filter['class']
      ).values('id')
    )
  )
```

This will generate a subquery for each filter that selects the `id` of the `Class` objects that match the filter criteria. The subquery is then used to filter the `Expression` objects in the main query.

Using subqueries can be more efficient than joining the same table multiple times, especially when dealing with large datasets. However, keep in mind that the performance of your query also depends on the size of your database and the hardware resources available.

--------
