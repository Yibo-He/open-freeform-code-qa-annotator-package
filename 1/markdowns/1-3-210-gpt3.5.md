
# Post \#68476576 [Link](https://stackoverflow.com/questions/68476576/)

## Python Match Case (Switch) Performance

**Vote**: 6 (473/702) **Views**: 4537 (533/702) 

**Internal ID** \#1-3-210

Created at 2021-07-21 21:19:17

Tags: `python` `python-3.x` `switch-statement` `match`

----------

#### Metadata:

Area: `Data Science & Machine Learning`

Language: `python` (full parsed tag list: `python`)

----------

**Notepad**


----------

I was expecting the Python `match`/`case` to have equal time access to each case, but seems like I was wrong. Any good explanation why?
Lets use the following example:
```
def match_case(decimal):
    match decimal:
      case '0':
        return "000"
      case '1':
        return "001"
      case '2':
        return "010"
      case '3':
        return "011"
      case '4':
        return "100"
      case '5':
        return "101"
      case '6':
        return "110"
      case '7':
        return "111"
      case _:
        return "NA"
```

And define a quick tool to measure the time:
```
import time
def measure_time(funcion):
    def measured_function(*args, **kwargs):
        init = time.time()
        c = funcion(*args, **kwargs)
        print(f"Input: {args[1]} Time: {time.time() - init}")
        return c
    return measured_function

@measure_time
def repeat(function, input):
    return [function(input) for i in range(10000000)]
```

If we run each `10000000` times each case, the times are the following:
```
for i in range(8):
    repeat(match_case, str(i))

# Input: 0 Time: 2.458001136779785
# Input: 1 Time: 2.36093807220459
# Input: 2 Time: 2.6832823753356934
# Input: 3 Time: 2.9995620250701904
# Input: 4 Time: 3.5054492950439453
# Input: 5 Time: 3.815168857574463
# Input: 6 Time: 4.164452791213989
# Input: 7 Time: 4.857251167297363
```

Just wondering why the access times are different. Isn't this optimised with perhaps a lookup table?. Note that I'm not interested in other ways of having equals access times (i.e. with dictionaries).


----------
        
## GPT3.5 Attempt \#0

The reason why the access times are different is due to the way the `match` statement is implemented in Python. When you use the `match` statement, Python generates a decision tree to determine which case to execute. This decision tree is optimized for the most common cases, but it is not optimized for all cases equally.

In your example, the decision tree generated by Python is optimized for the most common cases, which are the cases for `0`, `1`, `2`, and `3`. These cases are located at the top of the decision tree, which means that they are executed faster than the other cases.

On the other hand, the cases for `4`, `5`, `6`, and `7` are located at the bottom of the decision tree, which means that they are executed slower than the other cases. This is because the decision tree needs to traverse all the other cases before reaching these cases.

In general, the `match` statement in Python is optimized for the most common cases, but it is not optimized for all cases equally. If you need to have equal access times for all cases, you can use a dictionary instead of the `match` statement.

--------

## GPT3.5 Attempt \#1

The reason why the access times are different is due to the way the `match`/`case` statement is implemented in Python. 

When you use `match`/`case`, Python creates a decision tree to determine which case to execute. The decision tree is constructed based on the order of the cases in the code. The first case is evaluated first, then the second case, and so on. 

In your example, the first case is `'0'`, which means that if the input is `'0'`, it will be executed in the fastest time possible. However, if the input is `'7'`, Python has to evaluate all the previous cases before it can reach the last case, which is the default case. This is why the execution time for `'7'` is the slowest.

To optimize the execution time, you can reorder the cases in the code so that the most common cases are evaluated first. For example, if you expect `'0'`, `'1'`, and `'2'` to be the most common inputs, you can reorder the cases like this:

```
def match_case(decimal):
    match decimal:
      case '0':
        return "000"
      case '1':
        return "001"
      case '2':
        return "010"
      case '3':
        return "011"
      case '4':
        return "100"
      case '5':
        return "101"
      case '6':
        return "110"
      case '7':
        return "111"
      case _:
        return "NA"
```

With this order, the execution time for `'0'`, `'1'`, and `'2'` will be faster than before. However, the execution time for `'3'`, `'4'`, `'5'`, `'6'`, and `'7'` will still be slower than the first three cases. 

In summary, the execution time for `match`/`case` depends on the order of the cases in the code. You can optimize the execution time by reordering the cases based on the expected frequency of the inputs.

--------

## GPT3.5 Attempt \#2

The reason why the access times are different is because the `match` statement in Python is implemented using a binary search algorithm. This means that the cases are sorted and the algorithm starts by checking the middle case. If the value being matched is less than the middle case, it continues the search in the lower half of the cases, otherwise it continues in the upper half. This process is repeated until the matching case is found.

In your example, the cases are sorted in ascending order, so the algorithm will start by checking the middle case, which is `'3'`. If the value being matched is less than `'3'`, it will continue the search in the lower half of the cases (`'0'`, `'1'`, `'2'`). If it is greater than `'3'`, it will continue the search in the upper half (`'4'`, `'5'`, `'6'`, `'7'`). This binary search algorithm is more efficient than a linear search, but it does mean that the access times are not equal.

If you want to have equal access times, you could use a dictionary instead of a `match` statement. This would allow you to map each value to its corresponding output, without the need for a binary search. For example:

```
def match_case(decimal):
    cases = {
        '0': "000",
        '1': "001",
        '2': "010",
        '3': "011",
        '4': "100",
        '5': "101",
        '6': "110",
        '7': "111"
    }
    return cases.get(decimal, "NA")
```

This implementation uses the `get` method of the dictionary to look up the output for the given input. If the input is not in the dictionary, it returns the default value of `"NA"`. This implementation should have equal access times for each case.

--------
