
# Post \#73318552 [Link](https://stackoverflow.com/questions/73318552/)

## Django ORM query optimisation with multiple joins

**Vote**: 4 (532/702) **Views**: 449 (698/702) 

**Internal ID** \#1-3-227

Created at 2022-08-11 09:41:04

Tags: `python` `django` `django-models` `django-orm`

----------

#### Metadata:

Area: `Data Science & Machine Learning`

Language: `python` (full parsed tag list: `python`)

----------

**Notepad**


----------

In my app, I can describe an Entity using different Protocols, with each
Protocol being a collection of various Traits, and each Trait allows two or
more Classes. So, a Description is a collection of Expressions. E.g., I want to
describe an entity "John" with the Protocol "X" that comprises the following
two Traits and Classes:
 ABC
 1: Height
Available :
a. Short
b. Medium
c. Tall
 2: Weight
Available :
a. Light
b. Medium
c. Heavy
John's :  1: c. Tall,  2: b. Medium
My model specification (barebone essentials for simplicity):
```
class Protocol(models.Model):
    """
    A Protocol is a collection of Traits
    """
    name = models.CharField()

class Trait(models.Model):
    """
    Stores the Traits. Each Trait can have multiple Classes
    """

    name = models.CharField()
    protocol = models.ForeignKey(
        Protocol,
        help_text="The reference protocol of the trait",
    )

class Class(models.Model):
    """
    Stores the different Classes related to a Trait.
    """

    name = models.CharField()
    trait = models.ForeignKey(Trait)

class Description(models.Model):
    """
    Stores the Descriptions. A description is a collection of Expressions.
    """

    name = models.CharField()
    protocol = models.ForeignKey(
        Protocol,
        help_text="reference to the protocol used to make the description;\
            this will define which Traits will be available",
    )
    entity = models.ForeignKey(
        Entity,
        help_text="the Entity to which the description refers to",
    )

class Expression(models.Model):
    """
    Stores the expressions of entities related to a specific
    Description. It refers to one particular Class (which is
    then associated with a specific Trait)
    """

    class = models.ForeignKey(Class)
    description = models.ForeignKey(Description)
```

Following the previous example, let's say I want to find all the Entities that
are  or  (Trait 1) and  (Trait 2).
The query I'm now using is the following:
```
# This is the filter returned by the HTML form, which list
# all the available Classes for each Trait of the selected Protocol
filters = [
  {'trait': 1, 'class': [2, 3]},
  {'trait': 2, 'class': [6,]},
]

queryset = Description.objects.all()

for filter in filters:
  queryset = queryset.filter(expression_set__class__in=filter["class"])
```

The problem is that the query is slow (I have ATM ~1000 Descriptions, described with
a Protocol of 40 Traits, each Trait having 2 to 5 Classes). It takes about two
seconds to return the results even when filtering by only 5-6 Expressions.
I tried using `prefetch_related("expression_set")` or
`prefetch_related("expression_set__class")` but with no significant improvement.
The question is: can you suggest a way to improve the performance, or this is
simply the reality of searching through so many tables?
Thank you very much for your time.

---


EDIT:
The following is the query generated by the Manager when, e.g., eight filters (see previous code snippet) are applied.
```
SELECT "describe_description"."id",
       "describe_description"."name",
       "describe_description"."protocol_id",
  FROM "describe_description"
 INNER JOIN "describe_expression"
    ON ("describe_description"."id" = "describe_expression"."description_id")
 INNER JOIN "describe_expression" T4
    ON ("describe_description"."id" = T4."description_id")
 INNER JOIN "describe_expression" T6
    ON ("describe_description"."id" = T6."description_id")
 INNER JOIN "describe_expression" T8
    ON ("describe_description"."id" = T8."description_id")
 INNER JOIN "describe_expression" T10
    ON ("describe_description"."id" = T10."description_id")
 INNER JOIN "describe_expression" T12
    ON ("describe_description"."id" = T12."description_id")
 INNER JOIN "describe_expression" T14
    ON ("describe_description"."id" = T14."description_id")
 INNER JOIN "describe_expression" T16
    ON ("describe_description"."id" = T16."description_id")
 INNER JOIN "describe_expression" T18
    ON ("describe_description"."id" = T18."description_id")
 WHERE ("describe_expression"."class_id" IN (732) AND T4."class_id" IN (740) AND T6."class_id" IN (760) AND T8."class_id" IN (783) AND T10."class_id" IN (794) AND T12."class_id" IN (851) AND T14."class_id" IN (857) AND T16."class_id" IN (860) AND T18."class_id" IN (874))
```



----------
        
## GPT4 Attempt \#0

The performance issue you're experiencing is likely due to the fact that you're performing multiple JOIN operations in your query. Each JOIN operation can significantly slow down a query, especially if the tables involved have a large number of rows.

One way to improve the performance of your query is to denormalize your data. This means adding redundant data to your tables to avoid JOIN operations. For example, you could add a `protocol_id` field to your `Expression` model. This would allow you to filter expressions by protocol without having to join the `Description` table.

Another way to improve performance is to use database indexing. An index can significantly speed up data retrieval operations on a database table. You should consider adding indexes to the fields that you frequently use in your filter conditions, such as `class_id` and `description_id`.

You could also consider using a more efficient data structure for your filters. Instead of a list of dictionaries, you could use a dictionary of lists, where the keys are the trait ids and the values are the lists of class ids. This would allow you to filter expressions by trait and class with a single query, instead of having to loop through the filters.

Here's how you could implement these changes:

```python
# Add protocol_id to Expression model
class Expression(models.Model):
    ...
    protocol = models.ForeignKey(Protocol)

# Use a dictionary for filters
filters = {
  1: [2, 3],
  2: [6,],
}

# Filter expressions with a single query
queryset = Expression.objects.filter(protocol_id=protocol_id, class_id__in=class_ids)
```

Remember that denormalization and indexing come with their own trade-offs. Denormalization can make your data harder to manage and can increase storage requirements, while indexing can slow down write operations. Therefore, you should carefully consider these trade-offs before implementing these changes.

--------

## GPT4 Attempt \#1

The problem you're facing is due to the fact that you're performing multiple JOIN operations on the same table (`describe_expression`) for each filter. This can be quite expensive in terms of performance, especially when the number of filters increases.

One way to improve the performance is to use subqueries. Instead of joining the `describe_expression` table multiple times, you can create a subquery for each filter and then combine them using the `INTERSECT` operator. This way, you're performing the filtering operation on smaller datasets, which should be faster.

Here's how you can do it:

```python
from django.db.models import Subquery

# Create a list to store the subqueries
subqueries = []

for filter in filters:
    # Create a subquery for each filter
    subquery = Description.objects.filter(expression_set__class__in=filter["class"])
    subqueries.append(subquery)

# Start with the first subquery
queryset = Description.objects.filter(id__in=Subquery(subqueries[0].values('id')))

# Intersect the remaining subqueries
for subquery in subqueries[1:]:
    queryset = queryset.filter(id__in=Subquery(subquery.values('id')))

# Now you can use the queryset
```

This should give you the same results as your original query, but it should be faster because it performs the filtering operation on smaller datasets.

Also, make sure that you have proper indexing on your tables. Indexing can greatly improve the performance of your queries. In your case, you should have indexes on the `class_id` and `description_id` fields of the `describe_expression` table.

--------

## GPT4 Attempt \#2

The problem you are facing is due to the fact that you are performing multiple joins for each filter. This is because each filter is applied to the queryset in a separate filter operation, which results in a new join for each filter.

One way to improve the performance is to reduce the number of joins. You can achieve this by using the `Q` object to combine all the filters into one. Here's how you can do it:

```python
from django.db.models import Q

# This is the filter returned by the HTML form, which list
# all the available Classes for each Trait of the selected Protocol
filters = [
  {'trait': 1, 'class': [2, 3]},
  {'trait': 2, 'class': [6,]},
]

queryset = Description.objects.all()

# Create a Q object for each filter and combine them using the OR operator
q_objects = Q()

for filter in filters:
  q_objects |= Q(expression_set__class__in=filter["class"])

# Apply the combined filter to the queryset
queryset = queryset.filter(q_objects)
```

This will result in a single SQL query with a WHERE clause that combines all the conditions using the OR operator, instead of multiple INNER JOIN clauses.

Another way to improve the performance is to use indexing. If you often filter by `class_id`, you should add an index to this field. This can be done in the `Class` model like this:

```python
class Class(models.Model):
    """
    Stores the different Classes related to a Trait.
    """

    name = models.CharField()
    trait = models.ForeignKey(Trait)
    
    class Meta:
        indexes = [
            models.Index(fields=['id']),
        ]
```

This will speed up the lookup of `class_id` in the database.

Lastly, consider using `select_related` or `prefetch_related` to reduce the number of database queries. These methods are used to perform a SQL join and include related objects in the query results. This can significantly reduce the number of database queries and improve performance.

For example, if you often access the `protocol` of a `Description`, you can do:

```python
queryset = Description.objects.select_related('protocol').all()
```

This will perform a SQL join on the `protocol` table and include the related `Protocol` objects in the query results. As a result, when you access `description.protocol`, Django won't have to hit the database again, because the `Protocol` object is already fetched.

Remember, optimizing database queries is a complex task that requires a good understanding of both your data and how databases work. Always measure the performance before and after applying optimizations to make sure they actually improve the performance.

--------
