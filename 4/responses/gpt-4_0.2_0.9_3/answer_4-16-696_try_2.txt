The problem is that the command substitution `$(echo {} | sed 's/\?.*//g')` is evaluated before `find` starts its execution, so it doesn't replace `{}` with the actual file name. To solve this, you can use a shell script or a shell function to perform the renaming operation. Here is an example using a bash shell script:

```bash
find . -type f -name '*\?*' | while read -r file; do
    mv -- "$file" "$(echo "$file" | sed 's/\?.*//g')"
done
```

This script reads each file name output by `find`, and then uses `mv` to rename the file. The new name is generated by piping the original file name to `sed`, which removes the `?` and everything after it.

Please note that this script assumes that the `?` in the file names are actual question marks, not URL-encoded characters. If the `?` are URL-encoded characters, you'll need to decode them before you can rename the files.

Also, be aware that if multiple files resolve to the same name after removing the `?` and everything after it, this script will overwrite those files without warning. If this is a concern, you should modify the script to check for this condition and handle it appropriately.