1. There is no deadlock because the `std::unique_lock` object `lk` is being unlocked before sleeping and then locked again before checking the flag. This allows other threads to acquire the lock and continue execution while the current thread is sleeping. When the current thread wakes up, it tries to acquire the lock again before checking the flag. If the lock is already acquired by another thread, the current thread will wait until the lock is released by the other thread. This way, all threads can take turns acquiring the lock and checking the flag without causing a deadlock.

2. Defining a new `std::unique_lock` object in every thread associated with the same mutex lock allows each thread to acquire and release the lock independently. This is useful in situations where multiple threads need to access a shared resource, but only one thread should access the resource at a time. By using a mutex lock and `std::unique_lock` objects, each thread can acquire the lock when it needs to access the shared resource and release the lock when it is done, allowing other threads to access the resource in turn.