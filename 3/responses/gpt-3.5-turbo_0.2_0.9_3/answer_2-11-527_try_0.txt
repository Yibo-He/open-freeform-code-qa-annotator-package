1. There is no deadlock among those threads because the `std::unique_lock` object `lk` is released before the thread goes to sleep. When a thread calls `lk.unlock()`, it releases the lock on the mutex `m`. This allows other threads to acquire the lock and continue executing. When the thread wakes up from sleep, it calls `lk.lock()` to reacquire the lock on the mutex `m`. If another thread has acquired the lock in the meantime, the thread will wait until the lock is released before it can acquire it again. This way, the threads take turns acquiring the lock and releasing it, without causing a deadlock.

2. Defining a new `std::unique_lock` object in every thread associating to the same mutex lock means that each thread has its own lock on the mutex. This is necessary because a mutex can only be locked by one thread at a time. When a thread acquires the lock on the mutex, it prevents other threads from accessing the shared resource protected by the mutex. By creating a new `std::unique_lock` object in each thread, each thread has its own lock on the mutex, allowing them to take turns accessing the shared resource without interfering with each other.