1. There is no deadlock because the `std::unique_lock` is being used correctly. When a thread calls `lk.unlock()`, it releases the lock on the mutex, allowing other threads to acquire the lock. In this case, when thread A runs `lk.unlock()`, it releases the lock and thread B can acquire the lock by calling `lk.lock()`. When thread A tries to acquire the lock again by calling `lk.lock()`, it will wait until the lock is released by thread B. This is called a "blocking lock" and it ensures that only one thread can hold the lock at a time.

2. Defining a new `std::unique_lock` in every thread associating to the same mutex lock means that each thread has its own lock on the mutex. This is useful because it allows each thread to release the lock when it is not needed, allowing other threads to acquire the lock. If all threads were using the same `std::unique_lock`, they would all be waiting for each other to release the lock, causing a deadlock. By using separate locks, each thread can release the lock when it is done with it, allowing other threads to acquire the lock and continue executing.