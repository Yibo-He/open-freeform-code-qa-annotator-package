1. The reason there is no deadlock among those threads is because of the way the mutex is being used. When a thread enters the `wait_for_flag` function, it locks the mutex. If the flag is not set, it unlocks the mutex and then sleeps for a bit. This allows other threads to enter the function and lock the mutex. When the thread wakes up, it tries to lock the mutex again. If another thread has locked the mutex, it will block until the mutex is unlocked. This cycle continues until the flag is set. There is no deadlock because the threads are not holding onto the mutex while they are waiting for the flag to be set. They release the mutex before they start waiting, which allows other threads to make progress.

2. `std::unique_lock` is a RAII style mechanism for owning a mutex for the duration of a scoped block. When a `std::unique_lock` object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the `std::unique_lock` object was created, the `std::unique_lock` is destructed and the mutex is released. The reason a new `std::unique_lock` is defined in every thread is because each thread needs to independently acquire and release the lock. Even though they are all locking the same mutex, they are doing it at different times, so they each need their own `std::unique_lock` object.