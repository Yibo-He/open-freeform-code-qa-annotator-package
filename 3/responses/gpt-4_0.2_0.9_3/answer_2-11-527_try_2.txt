1. Deadlock is avoided in this code because of the way the lock and unlock operations are used. When a thread calls `lk.unlock()`, it releases the mutex, allowing other threads to acquire it. Then, it goes to sleep for 100 milliseconds. During this time, other threads have the opportunity to acquire the mutex. When the thread wakes up, it tries to re-acquire the mutex with `lk.lock()`. If another thread is currently holding the mutex, the calling thread will block until the mutex is available. This is not a deadlock situation because the thread holding the mutex will eventually release it, allowing the blocked thread to proceed. 

2. `std::unique_lock` is a general-purpose mutex ownership wrapper. It allows deferred locking, time-constrained attempts at locking, recursive locking, transfer of lock ownership, and use of conditional variables. In this code, `std::unique_lock` is used to automatically handle the locking and unlocking of the mutex. When a `std::unique_lock` object is created, it attempts to take ownership of the mutex. When the `std::unique_lock` goes out of scope, it automatically releases the mutex. This is a safer way to handle mutexes compared to manually locking and unlocking, because it ensures that the mutex is always properly released, even if an exception is thrown. 

In this code, a new `std::unique_lock` is created in each thread, all associated with the same mutex. This is because each thread needs to independently acquire and release the mutex. The `std::unique_lock` object is local to the function, so each thread has its own separate `std::unique_lock` object. However, all these `std::unique_lock` objects are associated with the same mutex, so they are all coordinating access to the same shared resource.